\subsubsection{الگوی \lr{Pool Allocation}}
\label{memPoolAllocSec}
\begin{RTL}
الگوی \lr{Pool Allocation} \cite{ref4}
برای سیستم‌هایی که بسیار پویا هستند
و تخصیص ایستا برای آن‌ها مناسب نیست، اما همچنان می‌خواهند از
مشکلات تخصیص حافظه پویا اجتناب کنند، مناسب است.
این الگو شامل ایجاد \lr{Pool}هایی از اشیاء در زمان راه‌اندازی است که
بر اساس درخواست کلاینت‌ها در دسترس قرار می‌گیرند.
این الگو برای سیستم‌هایی که به مجموعه‌ای از اشیاء برای اهداف مختلف
در زمان‌های مختلف اجرای سیستم نیاز دارند، مانند اشیاء داده یا پیام،
که نمی‌توان در زمان طراحی به‌طور بهینه پیش‌بینی یا توزیع کرد، مفید است.
اشیاء از \lr{Pool}ها تخصیص داده می‌شوند، استفاده می‌شوند
و سپس به آن بازگردانده می‌شوند، بنابراین از مشکلات تخصیص حافظه
در زمان اجرا و تکه‌تکه شدن حافظه اجتناب می‌شود.
با این حال، نیاز است که تعداد بهینه اشیاء مختلف در
زمان طراحی تعیین شود و این الگو اجازه رشد دینامیک تقاضای سیستم را نمی‌دهد.
\end{RTL}
\begin{figure}[h!]
\centering
\begin{tikzpicture}
    \lr{
        \umlclass[x=-1, y=-5]{Client}{
            \lr{}
        }{
            \lr{}
            }
            \umlclass[x=3]{GenericPoolManager}{
            \lr{initialize}\\
            \lr{allocate}\\
            \lr{release}
        }{  
            }
            \umlclass[x=7, y=-5]{ResoucePoolManager}{}{
                }
                \umlclass[x=10]{pooledClass}{
                    \lr{}
                }{
                    \lr{}
        }    
    \umluniassoc[mult1=*, attr2=ObjectServer|1, pos2=0.7]{Client}{ResoucePoolManager}
    \umlimport[mult2=bind]{ResoucePoolManager}{GenericPoolManager}
    \umlunicompo[mult1=1, attr2=freeObject|*, pos2=0.7]{GenericPoolManager}{pooledClass}
}
\end{tikzpicture}
\caption{دیاگرام کلاس \lr{Pool Allocation}}
\label{memPoolAllocClassDiag}
\end{figure}